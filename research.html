<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stock Buy Decision Helper</title>
  <style>
    body {
      background-color: #1e1e1e;
      color: white;
      font-family: Arial, sans-serif;
      max-width: 350px;
      margin: 20px auto;
      padding: 10px;
    }
    input, button {
      padding: 8px;
      margin: 5px 0;
      border-radius: 4px;
      border: none;
      width: 100%;
      box-sizing: border-box;
    }
    button {
      background-color: #e91e63;
      color: white;
      cursor: pointer;
    }
    .metric {
      margin: 10px 0;
    }
    .metric b {
      display: block;
      font-size: 1.1em;
      margin-bottom: 2px;
    }
    .metric small {
      color: #bbb;
      font-size: 0.85em;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      background: #2c2c2c;
      border-radius: 6px;
      min-height: 100px;
      white-space: pre-line;
    }
  </style>
</head>
<body>

<h2>Stock Buy Decision Helper</h2>
<input type="text" id="symbolInput" placeholder="Enter stock symbol (e.g. LMT)" />
<button id="fetchButton">Get Stock Data</button>

<div id="output">Enter a symbol and click "Get Stock Data".</div>

<script>
  const apiKey = "d151vgpr01qntv1fni6gd151vgpr01qntv1fni70";
  const output = document.getElementById("output");

  function toUnix(date) {
    return Math.floor(date.getTime() / 1000);
  }

  async function fetchMetrics(symbol) {
    try {
      const res = await fetch(`https://finnhub.io/api/v1/stock/metric?symbol=${symbol}&metric=all&token=${apiKey}`);
      const data = await res.json();
      if (data.metric) return data.metric;
      else return null;
    } catch {
      return null;
    }
  }

  async function fetchCandles(symbol, from, to) {
    try {
      const res = await fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${symbol}&resolution=D&from=${from}&to=${to}&token=${apiKey}`);
      const data = await res.json();
      if (data.s === "ok" && data.c && data.c.length > 0) return data;
      return null;
    } catch {
      return null;
    }
  }

  function percentChange(oldPrice, newPrice) {
    if (oldPrice === 0 || oldPrice === null || oldPrice === undefined || newPrice === null || newPrice === undefined) return null;
    return ((newPrice - oldPrice) / oldPrice) * 100;
  }

  function upDown(percent) {
    if (percent === null) return "N/A";
    return percent >= 0 ? "Up" : "Down";
  }

  function formatPercent(value) {
    if (value === null) return "N/A";
    return value.toFixed(2) + "%";
  }

  function formatNumber(value, decimals=2) {
    if (value === null || value === undefined || isNaN(value)) return "N/A";
    return value.toFixed(decimals);
  }

  // Find closing price on or after given date
  function getClosePriceOnOrAfter(candles, date) {
    if (!candles) return null;
    const target = toUnix(date);
    for (let i = 0; i < candles.t.length; i++) {
      if (candles.t[i] >= target) return candles.c[i];
    }
    // If none found, return first price if available
    return candles.c.length > 0 ? candles.c[0] : null;
  }

  async function update() {
    const symbol = document.getElementById("symbolInput").value.trim().toUpperCase();
    if (!symbol) {
      output.textContent = "Please enter a stock symbol.";
      return;
    }

    output.textContent = `Loading data for ${symbol}...`;

    const now = new Date();
    const todayUnix = toUnix(now);

    // Dates for historical data
    const oneYearAgo = new Date(now);
    oneYearAgo.setDate(now.getDate() - 370);

    const sixMonthsAgo = new Date(now);
    sixMonthsAgo.setDate(now.getDate() - 190);

    const oneMonthAgo = new Date(now);
    oneMonthAgo.setDate(now.getDate() - 30);

    const twoWeeksAgo = new Date(now);
    twoWeeksAgo.setDate(now.getDate() - 14);

    const oneWeekAgo = new Date(now);
    oneWeekAgo.setDate(now.getDate() - 7);

    // Fetch fundamentals
    const metrics = await fetchMetrics(symbol);

    // Fetch 1 year candles
    let candles = await fetchCandles(symbol, toUnix(oneYearAgo), todayUnix);

    if (!candles) {
      // fallback to 6 months
      candles = await fetchCandles(symbol, toUnix(sixMonthsAgo), todayUnix);
    }

    // Extract prices or set null if no data
    const priceToday = candles && candles.c.length ? candles.c[candles.c.length - 1] : null;
    const price1YearAgo = getClosePriceOnOrAfter(candles, oneYearAgo);
    const price6MonthsAgo = getClosePriceOnOrAfter(candles, sixMonthsAgo);
    const price1MonthAgo = getClosePriceOnOrAfter(candles, oneMonthAgo);
    const price2WeeksAgo = getClosePriceOnOrAfter(candles, twoWeeksAgo);
    const price1WeekAgo = getClosePriceOnOrAfter(candles, oneWeekAgo);

    // Calculate % changes or null if not possible
    const change1Day = (candles && candles.c.length > 1) ? percentChange(candles.c[candles.c.length - 2], priceToday) : null;
    const change1Month = percentChange(price1MonthAgo, priceToday);
    const change6Months = percentChange(price6MonthsAgo, priceToday);
    const change1Year = percentChange(price1YearAgo, priceToday);

    const weeklyChange = percentChange(price1WeekAgo, priceToday);
    const twoWeekChange = percentChange(price2WeeksAgo, priceToday);
    const monthlyChange = change1Month;

    // Fundamental metrics or null if missing
    const pe = metrics && metrics.peNormalizedAnnual ? metrics.peNormalizedAnnual : (metrics && metrics.peAnnual ? metrics.peAnnual : null);
    const debtEquity = metrics && metrics.debtToEquityAnnual ? metrics.debtToEquityAnnual : null;
    const epsGrowth = metrics && metrics.epsGrowth ? metrics.epsGrowth : null;
    const dividendYield = metrics && metrics.dividendYieldAnnual ? metrics.dividendYieldAnnual : null;

    // Buy decision logic with N/A fallback
    let buyScore = 0;
    let enoughDataForDecision = true;

    if (pe === null || debtEquity === null || epsGrowth === null || dividendYield === null ||
        monthlyChange === null || weeklyChange === null || twoWeekChange === null) {
      enoughDataForDecision = false;
    } else {
      if (pe > 0 && pe < 30) buyScore++;
      if (debtEquity > 0 && debtEquity < 1) buyScore++;
      if (epsGrowth > 0) buyScore++;
      if (dividendYield > 0) buyScore++;
      if (monthlyChange > 0) buyScore++;
      if (weeklyChange > 0) buyScore++;
      if (twoWeekChange > 0) buyScore++;
    }

    const buyRecommendation = enoughDataForDecision && buyScore >= 5 ? "BUY" : (enoughDataForDecision ? "HOLD/SELL" : "N/A");

    output.innerHTML = `
      <div class="metric"><b>Price Changes</b>
        <small>1 Day: ${formatPercent(change1Day)} (${upDown(change1Day)})</small><br/>
        <small>1 Month: ${formatPercent(change1Month)} (${upDown(change1Month)})</small><br/>
        <small>6 Months: ${formatPercent(change6Months)} (${upDown(change6Months)})</small><br/>
        <small>1 Year: ${formatPercent(change1Year)} (${upDown(change1Year)})</small>
      </div>

      <div class="metric"><b>Momentum</b>
        <small>This Week: ${upDown(weeklyChange)}</small><br/>
        <small>Last 2 Weeks: ${upDown(twoWeekChange)}</small><br/>
        <small>This Month: ${upDown(monthlyChange)}</small>
      </div>

      <div class="metric"><b>Fundamentals</b>
        <small>P/E Ratio: ${formatNumber(pe)}</small><br/>
        <small>Debt to Equity: ${formatNumber(debtEquity)}</small><br/>
        <small>EPS Growth: ${formatNumber(epsGrowth)}</small><br/>
        <small>Dividend Yield: ${formatNumber(dividendYield)}</small>
      </div>

      <div class="metric"><b>Recommendation:</b> ${buyRecommendation}</div>
    `;
  }

  document.getElementById("fetchButton").addEventListener("click", update);
</script>

</body>
</html>

